<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>机械臂参数辨识 - 知乎</title>
  <meta name="created-at" content="1767113767993">
  <meta name="updated-at" content="1767113767993">
  <meta name="source-type" content="zhihu">
  <meta name="source-url" content="https://zhuanlan.zhihu.com/p/1988007077843580810">
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 800px;
      margin: 40px auto;
      padding: 20px;
      background: #f5f5f5;
      color: #333;
    }
    h1 {
      color: #333;
      border-bottom: 2px solid #10a37f;
      padding-bottom: 10px;
    }
    .message-block {
      margin: 20px 0;
      padding: 16px;
      border-radius: 12px;
    }
    .role-user {
      background: #e8f4fd;
      border-left: 4px solid #3b82f6;
    }
    .role-ai {
      background: #f0fdf4;
      border-left: 4px solid #10b981;
    }
    .message-role {
      font-weight: 700;
      margin-bottom: 8px;
    }
    .role-user .message-role { color: #2563eb; }
    .role-ai .message-role { color: #059669; }
    .message-content {
      line-height: 1.6;
    }
    pre {
      background: #1a1a1a;
      color: #e5e5e5;
      padding: 16px;
      border-radius: 8px;
      overflow-x: auto;
    }
    code {
      font-family: 'Consolas', 'Monaco', monospace;
    }
    img {
      max-width: 100%;
      height: auto;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <h1>机械臂参数辨识 - 知乎</h1>
  <div class="message-block role-ai">
          <div class="message-role">AI</div>
          <div class="message-content"><h1>机械臂参数辨识</h1>
<div class="css-1od93p9"><div class="css-376mun"><span id="content"><div class="RichText ztext Post-RichText css-10o75c2" options="[object Object]"><h2 data-first-child="">1. 核心动力学参数（Core Dynamic Parameters）</h2><p data-pid="YrLO5io4">在参数辨识（Identification）模块中，程序<b>并没有直接使用物理直观的参数</b>（例如“质心位置 + 关于质心惯量”这种更直观的表述），而是使用<b>标准惯性参数（standard inertial parameters）</b>。<br>这样做的关键好处是：动力学方程对未知参数可以写成<b>线性形式</b>，从而允许使用 OLS / WLS / IRLS / TLS / EKF(RLS) 等经典辨识算法。</p><blockquote data-pid="HbIt5cn4"><b>核心思想</b>：把动力学写成<br><br><span class="math-tex" data-tex="  \tau = Y(q,\dot q,\ddot q)\,\beta + \varepsilon ">$  \tau = Y(q,\dot q,\ddot q)\,\beta + \varepsilon $</span><br> 其中 <span class="math-tex" data-tex="Y">$Y$</span> 是回归矩阵，<span class="math-tex" data-tex="\beta">$\beta$</span> 是待辨识参数向量。<br>这样就把“复杂非线性动力学”变成“对参数线性的回归问题”。</blockquote><p data-pid="T2JG0xws">对每一个连杆 <span class="math-tex" data-tex="i">$i$</span>（Link <span class="math-tex" data-tex="i">$i$</span>），定义 <b>12 个待辨识参数</b>。</p><hr><h2>1.1 惯性参数（Inertial Parameters）—— 10 个</h2><p data-pid="Ce4Ck2Ll">这些参数描述刚体的质量分布特性。</p><h3>1.1.1 质量（Mass）<span class="math-tex" data-tex="m_i">$m_i$</span></h3><ul style="list-style-type: disc; padding-left: 1.5em; margin-left: 0px; margin-top: 0.5em; margin-bottom: 0.5em;"><li data-pid="oWG8Cz8W" style="display: list-item; margin-top: 0.25em; margin-bottom: 0.25em;">连杆的总质量。</li></ul><h3>1.1.2 质量一阶矩（First Moment of Mass）<span class="math-tex" data-tex="h_i = m_i c_i">$h_i = m_i c_i$</span>（3 个）</h3><ul style="list-style-type: disc; padding-left: 1.5em; margin-left: 0px; margin-top: 0.5em; margin-bottom: 0.5em;"><li data-pid="j649NoOw" style="display: list-item; margin-top: 0.25em; margin-bottom: 0.25em;">包含 3 个分量：<span class="math-tex" data-tex="(m x_i, m y_i, m z_i)">$(m x_i, m y_i, m z_i)$</span></li><li data-pid="HyrUj8fN" style="display: list-item; margin-top: 0.25em; margin-bottom: 0.25em;">其中 <span class="math-tex" data-tex="c_i">$c_i$</span> 是质心在连杆坐标系中的位置。</li><li data-pid="pKj6Nocg" style="display: list-item; margin-top: 0.25em; margin-bottom: 0.25em;"><b>物理意义</b>：反映质心的“加权位置”。例如若 <span class="math-tex" data-tex="m x_i=0">$m x_i=0$</span>，说明质心在 <span class="math-tex" data-tex="X">$X$</span> 轴方向的坐标为 0。</li></ul><h3>1.1.3 转动惯量（Rotational Inertia）<span class="math-tex" data-tex="I_i">$I_i$</span>（6 个独立分量）</h3><ul style="list-style-type: disc; padding-left: 1.5em; margin-left: 0px; margin-top: 0.5em; margin-bottom: 0.5em;"><li data-pid="FmgvzGlT" style="display: list-item; margin-top: 0.25em; margin-bottom: 0.25em;">包含 6 个独立分量：<span class="math-tex" data-tex="(I_{xx}, I_{xy}, I_{xz}, I_{yy}, I_{yz}, I_{zz})">$(I_{xx}, I_{xy}, I_{xz}, I_{yy}, I_{yz}, I_{zz})$</span></li><li data-pid="WBD4KiTZ" style="display: list-item; margin-top: 0.25em; margin-bottom: 0.25em;"><b>注意</b>：这里使用的是<b>关于连杆坐标系原点</b>的惯量，不是关于质心（COM）的惯量。</li><li data-pid="xFukeriC" style="display: list-item; margin-top: 0.25em; margin-bottom: 0.25em;">两者关系（平行轴定理）： <span class="math-tex" data-tex="   I_{\text{origin}} = I_{\text{com}} + m\left(c^T c \cdot \mathbf{1} - c c^T\right)   ">$   I_{\text{origin}} = I_{\text{com}} + m\left(c^T c \cdot \mathbf{1} - c c^T\right)   $</span></li></ul><blockquote data-pid="jEd9riZP"> 说明：使用“关于坐标系原点的惯量”是因为递归牛顿–欧拉（RNEA）等算法常以连杆坐标系原点进行空间力/力矩传播，写成标准参数形式更方便线性化。</blockquote><hr><h2>1.2 摩擦参数（Friction Parameters）—— 2 个</h2><p data-pid="wVqJrzx4">用于补偿关节处的非线性摩擦：</p><h3>1.2.1 粘滞摩擦（Viscous Friction）<span class="math-tex" data-tex="F_{v,i}">$F_{v,i}$</span></h3><ul style="list-style-type: disc; padding-left: 1.5em; margin-left: 0px; margin-top: 0.5em; margin-bottom: 0.5em;"><li data-pid="PzK9hIrm" style="display: list-item; margin-top: 0.25em; margin-bottom: 0.25em;">与速度成正比的阻力： <span class="math-tex" data-tex="   \tau_f \propto \dot{q}   ">$   \tau_f \propto \dot{q}   $</span></li></ul><h3>1.2.2 库伦摩擦（Coulomb Friction）<span class="math-tex" data-tex="F_{c,i}">$F_{c,i}$</span></h3><ul style="list-style-type: disc; padding-left: 1.5em; margin-left: 0px; margin-top: 0.5em; margin-bottom: 0.5em;"><li data-pid="9DLBBIgm" style="display: list-item; margin-top: 0.25em; margin-bottom: 0.25em;">常值阻力，方向与速度相反： <span class="math-tex" data-tex="   \tau_f \propto \text{sign}(\dot{q})   ">$   \tau_f \propto \text{sign}(\dot{q})   $</span></li></ul><hr><h2>2. 动力学方程的程序构建与解算方法</h2><p data-pid="fIRh5EUy">机械臂动力学方程常见两种等价的程序化表达：</p><ul style="list-style-type: disc; padding-left: 1.5em; margin-left: 0px; margin-top: 0.5em; margin-bottom: 0.5em;"><li data-pid="EUqfaVZ1" style="display: list-item; margin-top: 0.25em; margin-bottom: 0.25em;"><b>(A) 拉格朗日 / 牛顿–欧拉形式</b>：逐项求 <span class="math-tex" data-tex="M, C, g">$M, C, g$</span></li><li data-pid="Vo0wjrJ0" style="display: list-item; margin-top: 0.25em; margin-bottom: 0.25em;"><b>(B) 线性参数化形式</b>：显式构造回归矩阵 <span class="math-tex" data-tex="Y">$Y$</span>，得到 <span class="math-tex" data-tex="Y\beta=\tau">$Y\beta=\tau$</span></li></ul><hr><h2>2.1 标准拉格朗日方程的程序解算（基于 RNEA）</h2><p data-pid="45ryt0eH">标准形式： </p><p data-pid="1FGIlcUz"><span class="math-tex" data-tex=" M(q)\ddot{q} + C(q, \dot{q})\dot{q} + g(q) = \tau - F(\dot{q}) ">$ M(q)\ddot{q} + C(q, \dot{q})\dot{q} + g(q) = \tau - F(\dot{q}) $</span></p><p class="ztext-empty-paragraph"><br></p><p data-pid="2_75YTGa">程序通常利用递归牛顿–欧拉算法（RNEA）来计算各项。RNEA 包含两个核心步骤：</p><ol style="list-style-type: decimal; padding-left: 1.5em; margin-left: 0px; margin-top: 0.5em; margin-bottom: 0.5em;"><li data-pid="_B-xBR3U" style="display: list-item; margin-top: 0.25em; margin-bottom: 0.25em;"><b>前向递推（Forward Pass）</b>：从基座向末端计算各连杆运动学量<br> </li></ol><ul style="list-style-type: disc; padding-left: 1.5em; margin-left: 0px; margin-top: 0.5em; margin-bottom: 0.5em;"><li data-pid="36HuFPIp" style="display: list-item; margin-top: 0.25em; margin-bottom: 0.25em;">角速度 <span class="math-tex" data-tex="\omega">$\omega$</span>、线速度 <span class="math-tex" data-tex="v">$v$</span><br></li><li data-pid="ZOpHt7VE" style="display: list-item; margin-top: 0.25em; margin-bottom: 0.25em;">角加速度 <span class="math-tex" data-tex="\dot{\omega}">$\dot{\omega}$</span>、线加速度 <span class="math-tex" data-tex="\dot{v}">$\dot{v}$</span></li></ul><p class="ztext-empty-paragraph"><br></p><ol style="list-style-type: decimal; padding-left: 1.5em; margin-left: 0px; margin-top: 0.5em; margin-bottom: 0.5em;"><li data-pid="knVmHlfc" style="display: list-item; margin-top: 0.25em; margin-bottom: 0.25em;"><b>后向递推（Backward Pass）</b>：从末端向基座利用牛顿–欧拉方程计算受力，并投影得到关节力矩 <span class="math-tex" data-tex="\tau">$\tau$</span></li></ol><hr><h3>2.1.1 惯性矩阵 <span class="math-tex" data-tex="M(q)">$M(q)$</span> 的计算</h3><p data-pid="ZpEE4YeL">利用 <span class="math-tex" data-tex="\dot{q}=\mathbf{0},\ g=\mathbf{0}">$\dot{q}=\mathbf{0},\ g=\mathbf{0}$</span> 时方程退化为： </p><p data-pid="PU_2wnD6"><span class="math-tex" data-tex=" M(q)\ddot{q} = \tau ">$ M(q)\ddot{q} = \tau $</span></p><p class="ztext-empty-paragraph"><br></p><p data-pid="b6wwd2Hh">若取 <span class="math-tex" data-tex="\ddot{q} = e_j">$\ddot{q} = e_j$</span>（仅第 <span class="math-tex" data-tex="j">$j$</span> 关节有单位加速度），则计算出的 <span class="math-tex" data-tex="\tau">$\tau$</span> 即为 <span class="math-tex" data-tex="M">$M$</span> 的第 <span class="math-tex" data-tex="j">$j$</span> 列： </p><p data-pid="TC33Ulym"><span class="math-tex" data-tex=" M_{:,j} = \text{RNEA}(q,\ \dot{q}=\mathbf{0},\ \ddot{q}=e_j,\ g=\mathbf{0}) ">$ M_{:,j} = \text{RNEA}(q,\ \dot{q}=\mathbf{0},\ \ddot{q}=e_j,\ g=\mathbf{0}) $</span></p><p class="ztext-empty-paragraph"><br></p><blockquote data-pid="aj1VyZza"> 实现层面：需要对每个 <span class="math-tex" data-tex="j=1,\dots,n">$j=1,\dots,n$</span> 调用一次 RNEA，拼出整块 <span class="math-tex" data-tex="M(q)">$M(q)$</span>。</blockquote><hr><h3>2.1.2 科里奥利与离心力项 <span class="math-tex" data-tex="C(q,\dot{q})\dot{q}">$C(q,\dot{q})\dot{q}$</span> 的计算</h3><p data-pid="WlBNdFGX">令 <span class="math-tex" data-tex="\ddot{q}=\mathbf{0},\ g=\mathbf{0}">$\ddot{q}=\mathbf{0},\ g=\mathbf{0}$</span>，方程退化为： </p><p data-pid="eNVSDa2j"><span class="math-tex" data-tex=" C(q, \dot{q})\dot{q} = \tau ">$ C(q, \dot{q})\dot{q} = \tau $</span></p><p class="ztext-empty-paragraph"><br></p><p data-pid="fK3RKUJ-">因此： </p><p data-pid="DBLigjQM"><span class="math-tex" data-tex=" \tau_{\text{coriolis}} = \text{RNEA}(q,\ \dot{q},\ \ddot{q}=\mathbf{0},\ g=\mathbf{0}) ">$ \tau_{\text{coriolis}} = \text{RNEA}(q,\ \dot{q},\ \ddot{q}=\mathbf{0},\ g=\mathbf{0}) $</span></p><p class="ztext-empty-paragraph"><br></p><hr><h3>2.1.3 重力项 <span class="math-tex" data-tex="g(q)">$g(q)$</span> 的计算</h3><p data-pid="YmjXOoVH">令 <span class="math-tex" data-tex="\dot{q}=\mathbf{0},\ \ddot{q}=\mathbf{0}">$\dot{q}=\mathbf{0},\ \ddot{q}=\mathbf{0}$</span>，方程退化为： </p><p data-pid="hN-gtxAZ"><span class="math-tex" data-tex=" g(q) = \tau ">$ g(q) = \tau $</span></p><p class="ztext-empty-paragraph"><br></p><p data-pid="SWO56A0t">因此： </p><p data-pid="yiiKz7iy"><span class="math-tex" data-tex=" g(q) = \text{RNEA}(q,\ \dot{q}=\mathbf{0},\ \ddot{q}=\mathbf{0},\ g=g_{\text{world}}) ">$ g(q) = \text{RNEA}(q,\ \dot{q}=\mathbf{0},\ \ddot{q}=\mathbf{0},\ g=g_{\text{world}}) $</span></p><p class="ztext-empty-paragraph"><br></p><hr><h2>2.2 回归矩阵 <span class="math-tex" data-tex="Y">$Y$</span> 的解算（线性参数化）</h2><p data-pid="l7mzu5zj">为了进行参数辨识，必须构建线性方程： </p><p data-pid="qWjFJWML"><span class="math-tex" data-tex=" Y(q, \dot{q}, \ddot{q})\,\pi = \tau ">$ Y(q, \dot{q}, \ddot{q})\,\pi = \tau $</span></p><p data-pid="-vS3yGa2"> 程序通过<b>直接计算每个参数的系数</b>来填充矩阵 <span class="math-tex" data-tex="Y">$Y$</span>。</p><p class="ztext-empty-paragraph"><br></p><hr><h3>2.2.1（注）关于加速度 <span class="math-tex" data-tex="\ddot{q}">$\ddot{q}$</span> 的获取</h3><p data-pid="QQ4EgD79">在实际物理系统中，关节加速度 <span class="math-tex" data-tex="\ddot{q}">$\ddot{q}$</span> 极少直接测量（因缺乏传感器且直接微分噪声过大）。<br>程序中使用的 <span class="math-tex" data-tex="\dot{q}, \ddot{q}">$\dot{q}, \ddot{q}$</span> 通常是基于位置编码器采集的 <span class="math-tex" data-tex="q">$q$</span> 序列，经过离线平滑滤波（如<b>零相位 Butterworth 滤波</b>）后，通过中心差分计算得到的。</p><blockquote data-pid="Pvvi356G"> 工程经验：如果 <span class="math-tex" data-tex="\ddot{q}">$\ddot{q}$</span> 噪声大，会直接污染 <span class="math-tex" data-tex="Y">$Y$</span>，导致 OLS 偏差、条件数恶化、参数发散等问题，所以“滤波 + 差分”的细节非常关键。</blockquote><hr><h3>2.2.2 运动学前向递推（Kinematics Forward Pass）</h3><p data-pid="yEuQBItD">首先计算连杆 <span class="math-tex" data-tex="i">$i$</span> 原点的运动属性：</p><ul style="list-style-type: disc; padding-left: 1.5em; margin-left: 0px; margin-top: 0.5em; margin-bottom: 0.5em;"><li data-pid="mjcSTyV3" style="display: list-item; margin-top: 0.25em; margin-bottom: 0.25em;">角速度与角加速度：<span class="math-tex" data-tex="\omega_i, \alpha_i">$\omega_i, \alpha_i$</span></li><li data-pid="4r7pVy05" style="display: list-item; margin-top: 0.25em; margin-bottom: 0.25em;">原点线加速度（含重力）： <span class="math-tex" data-tex="   \hat{a}_i = \dot{v}_i - g   ">$   \hat{a}_i = \dot{v}_i - g   $</span></li><li data-pid="oSunsABf" style="display: list-item; margin-top: 0.25em; margin-bottom: 0.25em;">雅可比矩阵：<span class="math-tex" data-tex="J_{v,i}, J_{\omega,i}">$J_{v,i}, J_{\omega,i}$</span></li></ul><hr><h3>2.2.3 逐列填充回归矩阵（Column-by-Column Filling）</h3><p data-pid="UD6ToGDp">程序针对连杆 <span class="math-tex" data-tex="i">$i$</span> 的 12 个待辨识参数（10 个惯性参数 + 2 个摩擦参数），计算其对应的 <span class="math-tex" data-tex="Y">$Y$</span> 矩阵列块： </p><p data-pid="X_b4W0T7"><span class="math-tex" data-tex=" Y_{\text{block}} \in \mathbb{R}^{n \times 12} ">$ Y_{\text{block}} \in \mathbb{R}^{n \times 12} $</span></p><p class="ztext-empty-paragraph"><br></p><h3>(1) 质量 <span class="math-tex" data-tex="m">$m$</span> 的系数（第 1 列）</h3><p data-pid="BMnUkgsO"><span class="math-tex" data-tex=" \text{Col}_m = J_{v,i}^T \cdot \hat{a}_i ">$ \text{Col}_m = J_{v,i}^T \cdot \hat{a}_i $</span></p><ul style="list-style-type: disc; padding-left: 1.5em; margin-left: 0px; margin-top: 0.5em; margin-bottom: 0.5em;"><li data-pid="GFUsF1hB" style="display: list-item; margin-top: 0.25em; margin-bottom: 0.25em;"><b>代码逻辑</b>：直接将转换到关节空间的线加速度投影填入该列。</li></ul><h3>(2) 一阶矩 <span class="math-tex" data-tex="h">$h$</span> 的系数（第 2–4 列）</h3><p data-pid="gsvb72PG">源于： </p><p data-pid="gj5FfXRy"><span class="math-tex" data-tex=" \omega \times (\omega \times h) + \alpha \times h ">$ \omega \times (\omega \times h) + \alpha \times h $</span></p><p data-pid="P5uANCFs"> 程序通过提取 <span class="math-tex" data-tex="h">$h$</span> 的系数矩阵： </p><p data-pid="2jaOmu2H"><span class="math-tex" data-tex=" \text{Col}_{h} = J_{v,i}^T \cdot [\text{skew}(\alpha_i) + \text{skew}(\omega_i)^2] ">$ \text{Col}_{h} = J_{v,i}^T \cdot [\text{skew}(\alpha_i) + \text{skew}(\omega_i)^2] $</span></p><p class="ztext-empty-paragraph"><br></p><blockquote data-pid="Jp94ojPa"> 解释：<span class="math-tex" data-tex="\text{skew}(\cdot)">$\text{skew}(\cdot)$</span> 是把向量变成反对称矩阵，用于表示叉乘（<span class="math-tex" data-tex="\omega \times x = \text{skew}(\omega)x">$\omega \times x = \text{skew}(\omega)x$</span>）。<br>因此 <span class="math-tex" data-tex="\omega \times(\omega \times h)">$\omega \times(\omega \times h)$</span> 可以写成 <span class="math-tex" data-tex="\text{skew}(\omega)^2 h">$\text{skew}(\omega)^2 h$</span>。</blockquote><h3>(3) 惯量 <span class="math-tex" data-tex="I">$I$</span> 的系数（第 5–10 列）</h3><p data-pid="9d9oEKrq">源于刚体转动项： </p><p data-pid="JrWn80MV"><span class="math-tex" data-tex=" \tau = I \alpha + \omega \times (I \omega) ">$ \tau = I \alpha + \omega \times (I \omega) $</span></p><p data-pid="_JBvMrGt"> 由于 <span class="math-tex" data-tex="I">$I$</span> 分散在 6 个分量中，需要针对每个分量（如 <span class="math-tex" data-tex="I_{xx}">$I_{xx}$</span>）单独计算其对力矩的贡献。例如： </p><p data-pid="8QwL3u4N"><span class="math-tex" data-tex=" \text{Col}_{I_{xx}} = J_{\omega,i}^T \cdot (\alpha_{x} e_x + \omega \times (\omega_x e_x)) ">$ \text{Col}_{I_{xx}} = J_{\omega,i}^T \cdot (\alpha_{x} e_x + \omega \times (\omega_x e_x)) $</span></p><p data-pid="AjYGzgYy"> 对 <span class="math-tex" data-tex="I_{xy}, \dots, I_{zz}">$I_{xy}, \dots, I_{zz}$</span> 依次类推。</p><p class="ztext-empty-paragraph"><br></p><h3>(4) 摩擦参数的系数（第 11–12 列）</h3><p data-pid="z-IQHqSX">摩擦力矩仅作用于当前关节轴，不涉及空间力传递。对于第 <span class="math-tex" data-tex="i">$i$</span> 个关节，其对应的回归矩阵元素为： </p><p data-pid="MOAeN4S8"><span class="math-tex" data-tex=" \text{Col}_{F_{v,i}} = \dot{q}_i,\quad \text{Col}_{F_{c,i}} = \text{sign}(\dot{q}_i) ">$ \text{Col}_{F_{v,i}} = \dot{q}_i,\quad \text{Col}_{F_{c,i}} = \text{sign}(\dot{q}_i) $</span></p><p data-pid="A47QKgHc"> 注意：这两个参数仅对第 <span class="math-tex" data-tex="i">$i$</span> 个关节的力矩方程有贡献（即 <span class="math-tex" data-tex="Y">$Y$</span> 矩阵的第 <span class="math-tex" data-tex="i">$i$</span> 行），在其他行中均为 0。</p><p class="ztext-empty-paragraph"><br></p><hr><h3>2.2.4 小结：为何“逐列填充”很重要</h3><p data-pid="MeGFpJQN">通过这种方式，程序通过单次遍历即可直接构建出完整的 <span class="math-tex" data-tex="Y">$Y$</span> 矩阵，而无需显式推导复杂的符号公式。<br>这通常比符号推导更稳定、更易维护，也更适合工程实现（尤其是多连杆、多传感器、含摩擦模型时）。</p><hr><h2>3. 数据与建模（Data &amp; Modeling）</h2><p data-pid="wA88FgLt">辨识算法使用实验数据 <span class="math-tex" data-tex="(q, \dot q, \tau)">$(q, \dot q, \tau)$</span>，其中：</p><ul style="list-style-type: disc; padding-left: 1.5em; margin-left: 0px; margin-top: 0.5em; margin-bottom: 0.5em;"><li data-pid="74IonrG9" style="display: list-item; margin-top: 0.25em; margin-bottom: 0.25em;"><span class="math-tex" data-tex="q">$q$</span>：关节角</li><li data-pid="Nigv6V9K" style="display: list-item; margin-top: 0.25em; margin-bottom: 0.25em;"><span class="math-tex" data-tex="\dot q">$\dot q$</span>：关节角速度</li><li data-pid="ijJd07sP" style="display: list-item; margin-top: 0.25em; margin-bottom: 0.25em;"><span class="math-tex" data-tex="\tau">$\tau$</span>：关节力矩</li></ul><p data-pid="2CrB7b62">加速度使用数值微分得到（中心差分）： </p><p data-pid="_58-ZGly"><span class="math-tex" data-tex=" \ddot q_k \approx \frac{\dot q_{k+1}-\dot q_{k-1}}{t_{k+1}-t_{k-1}}, \quad \ddot q_1 = \ddot q_2,\ \ddot q_N = \ddot q_{N-1}. ">$ \ddot q_k \approx \frac{\dot q_{k+1}-\dot q_{k-1}}{t_{k+1}-t_{k-1}}, \quad \ddot q_1 = \ddot q_2,\ \ddot q_N = \ddot q_{N-1}. $</span></p><p class="ztext-empty-paragraph"><br></p><p data-pid="vXEnSvly">动力学回归模型写成线性参数形式： </p><p data-pid="lm3obmBt"><span class="math-tex" data-tex=" \tau_k = Y(q_k,\dot q_k,\ddot q_k)\,\beta + \varepsilon_k, ">$ \tau_k = Y(q_k,\dot q_k,\ddot q_k)\,\beta + \varepsilon_k, $</span></p><p data-pid="dlEeJUI0"> 其中 <span class="math-tex" data-tex="Y">$Y$</span> 为观测矩阵（回归矩阵），<span class="math-tex" data-tex="\beta">$\beta$</span> 为待辨识参数向量。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="6kkjlLMI">堆叠 <span class="math-tex" data-tex="N">$N$</span> 个时刻后： </p><p data-pid="5sOe0TKg"><span class="math-tex" data-tex=" W = \begin{bmatrix} Y(q_1,\dot q_1,\ddot q_1)\\ \vdots\\ Y(q_N,\dot q_N,\ddot q_N) \end{bmatrix}, \quad y = \mathrm{vec}(\tau_1,\ldots,\tau_N), ">$ W = \begin{bmatrix} Y(q_1,\dot q_1,\ddot q_1)\\ \vdots\\ Y(q_N,\dot q_N,\ddot q_N) \end{bmatrix}, \quad y = \mathrm{vec}(\tau_1,\ldots,\tau_N), $</span></p><p data-pid="6-vFFRPv"> 得到线性系统： </p><p data-pid="ZxH1Kdtx"><span class="math-tex" data-tex=" y = W\beta + \varepsilon. ">$ y = W\beta + \varepsilon. $</span></p><p class="ztext-empty-paragraph"><br></p><hr><h2>3.1 参数向量定义（本仓库形式）</h2><p data-pid="Lz7X86y1">本仓库的参数向量采用“标准惯性参数 + 摩擦参数”的组合形式。对于第 <span class="math-tex" data-tex="i">$i$</span> 个连杆，其参数向量 <span class="math-tex" data-tex="\pi_i \in \mathbb{R}^{12}">$\pi_i \in \mathbb{R}^{12}$</span> 定义为： </p><p data-pid="HHbuF2AV"><span class="math-tex" data-tex=" \pi_i = [m_i,\ h_{ix},\ h_{iy},\ h_{iz},\ I_{ixx},\ I_{ixy},\ I_{ixz},\ I_{iyy},\ I_{iyz},\ I_{izz},\ F_{vi},\ F_{ci}]^T ">$ \pi_i = [m_i,\ h_{ix},\ h_{iy},\ h_{iz},\ I_{ixx},\ I_{ixy},\ I_{ixz},\ I_{iyy},\ I_{iyz},\ I_{izz},\ F_{vi},\ F_{ci}]^T $</span></p><p class="ztext-empty-paragraph"><br></p><p data-pid="jOFjjHl2">整个系统的待辨识参数向量 <span class="math-tex" data-tex="\beta \in \mathbb{R}^{12n}">$\beta \in \mathbb{R}^{12n}$</span> 为所有连杆参数的堆叠： </p><p data-pid="p8wxbxnp"><span class="math-tex" data-tex=" \beta = [\pi_1^T,\ \pi_2^T,\ \ldots,\ \pi_n^T]^T ">$ \beta = [\pi_1^T,\ \pi_2^T,\ \ldots,\ \pi_n^T]^T $</span></p><p class="ztext-empty-paragraph"><br></p><hr><h2>4. 算法与实现对应（Algorithm–Implementation Mapping）</h2><hr><h2>4.1 OLS（普通最小二乘）</h2><p data-pid="-Am6mSdi">目标函数： </p><p data-pid="AmadqRME"><span class="math-tex" data-tex=" \hat\beta = \arg\min_\beta \|W\beta - y\|_2^2. ">$ \hat\beta = \arg\min_\beta \|W\beta - y\|_2^2. $</span></p><p data-pid="sV6rigbl"> 实现中使用<b>带列主元的 QR 分解</b>求解。</p><p class="ztext-empty-paragraph"><br></p><blockquote data-pid="waiPZtT2"> 解释：QR（带列主元）通常比直接求 <span class="math-tex" data-tex="(W^TW)^{-1}">$(W^TW)^{-1}$</span> 更稳定，尤其当 <span class="math-tex" data-tex="W">$W$</span> 条件数较大时。</blockquote><hr><h2>4.2 WLS（加权最小二乘）</h2><p data-pid="8RhSxy-2">先用 OLS 得到残差： </p><p data-pid="sTaL7ocX"><span class="math-tex" data-tex=" r = y - W\beta_{\text{OLS}} ">$ r = y - W\beta_{\text{OLS}} $</span></p><p data-pid="6UgWSv3k"> 再按关节维度估计噪声方差： </p><p data-pid="s1h9d6DX"><span class="math-tex" data-tex=" \sigma_j^2 = \frac{1}{N}\sum_{k=1}^N r_{k,j}^2, \quad w_j = \frac{1}{\sqrt{\sigma_j^2}}. ">$ \sigma_j^2 = \frac{1}{N}\sum_{k=1}^N r_{k,j}^2, \quad w_j = \frac{1}{\sqrt{\sigma_j^2}}. $</span></p><p data-pid="JkHK-Rwn"> 然后对每一行施加权重 <span class="math-tex" data-tex="w_j">$w_j$</span>，求解： </p><p data-pid="lpkGb3Ib"><span class="math-tex" data-tex=" \hat\beta = \arg\min_\beta \|W_w\beta - y_w\|_2^2. ">$ \hat\beta = \arg\min_\beta \|W_w\beta - y_w\|_2^2. $</span></p><p class="ztext-empty-paragraph"><br></p><blockquote data-pid="UcDaVWdk"> 解释：这等价于假设不同关节的测量噪声方差不同，WLS 会降低“噪声更大关节”的影响。</blockquote><hr><h2>4.3 IRLS（鲁棒迭代加权最小二乘）</h2><p data-pid="bldcrAFH">使用 Huber 权重：</p><p data-pid="GZ4owxuE"><span class="math-tex" data-tex=" \sigma = \frac{\mathrm{median}(|r|)}{0.6745},\quad \delta = 1.345\,\sigma, ">$ \sigma = \frac{\mathrm{median}(|r|)}{0.6745},\quad \delta = 1.345\,\sigma, $</span></p><p data-pid="nDTmdJqB"><span class="math-tex" data-tex=" w_i = \begin{cases} 1, &amp; |r_i|\le \delta\\ \delta/|r_i|, &amp; |r_i|&gt;\delta \end{cases} ">$ w_i = \begin{cases} 1, &amp; |r_i|\le \delta\\ \delta/|r_i|, &amp; |r_i|&gt;\delta \end{cases} $</span></p><p data-pid="rIsKEkND">迭代解加权最小二乘，直至： </p><p data-pid="Pz4S6hLL"><span class="math-tex" data-tex=" \|\beta_{k+1}-\beta_k\|&lt;\text{tol}. ">$ \|\beta_{k+1}-\beta_k\|&lt;\text{tol}. $</span></p><p class="ztext-empty-paragraph"><br></p><blockquote data-pid="ZJfmyKr4"> 解释：IRLS 用“自适应权重”抑制离群点（例如碰撞、饱和、编码器毛刺导致的异常样本）。</blockquote><hr><h2>4.4 TLS（总最小二乘）</h2><p data-pid="7WdBAns-">构造增广矩阵： </p><p data-pid="MnMZmRwM"><span class="math-tex" data-tex=" Z=[W\ \ y] ">$ Z=[W\ \ y] $</span></p><p data-pid="hUzrlU51"> 做 SVD： </p><p data-pid="E7xjlAtZ"><span class="math-tex" data-tex=" Z = U\Sigma V^\top. ">$ Z = U\Sigma V^\top. $</span></p><p data-pid="BzG92iwn"> 取最小奇异值对应的右奇异向量 <span class="math-tex" data-tex="v=[v_\beta;\ v_y]">$v=[v_\beta;\ v_y]$</span>，得到： </p><p data-pid="W69U50L5"><span class="math-tex" data-tex=" \hat\beta = -\frac{v_\beta}{v_y}. ">$ \hat\beta = -\frac{v_\beta}{v_y}. $</span></p><p data-pid="CkyGBBEA"> 若 <span class="math-tex" data-tex="v_y\approx 0">$v_y\approx 0$</span> 则回退到 OLS。</p><p class="ztext-empty-paragraph"><br></p><blockquote data-pid="iVfTgPf_"> 解释：TLS 允许 <span class="math-tex" data-tex="W">$W$</span> 和 <span class="math-tex" data-tex="y">$y$</span> 都有误差（而 OLS 仅假设 <span class="math-tex" data-tex="y">$y$</span> 有误差）。</blockquote><hr><h2>4.5 EKF（以 RLS 形式实现的扩展卡尔曼）</h2><p data-pid="Cbe4Bs67">实现为逐行（标量）递推： </p><p data-pid="Vu61jHa9"><span class="math-tex" data-tex=" K = P H^\top (H P H^\top + R)^{-1}, \quad \beta \leftarrow \beta + K (y - H\beta), ">$ K = P H^\top (H P H^\top + R)^{-1}, \quad \beta \leftarrow \beta + K (y - H\beta), $</span></p><p data-pid="YS_tmE8K"><span class="math-tex" data-tex=" P \leftarrow (I - K H)P. ">$ P \leftarrow (I - K H)P. $</span></p><p data-pid="t88S2OZr"> 初始化： </p><p data-pid="o-X4RgJ7"><span class="math-tex" data-tex=" P_0=100I,\quad R=0.1. ">$ P_0=100I,\quad R=0.1. $</span></p><p class="ztext-empty-paragraph"><br></p><blockquote data-pid="oZeaEE8W"> 说明：这里的“EKF”更像是把参数当作状态，采用 RLS 形式在线更新；若 <span class="math-tex" data-tex="H">$H$</span> 随 <span class="math-tex" data-tex="q,\dot q,\ddot q">$q,\dot q,\ddot q$</span> 变化，可视为非线性系统的线性化递推。</blockquote><hr><h2>4.6 ML（Levenberg–Marquardt）</h2><p data-pid="jFGjugQw">最小化： </p><p data-pid="gVV9bOUn"><span class="math-tex" data-tex=" \min_\beta \ \frac{1}{2}\|W\beta - y\|_2^2 ">$ \min_\beta \ \frac{1}{2}\|W\beta - y\|_2^2 $</span></p><p data-pid="Kt5YxEJV"> 并使用 LM 算法求解。由于模型线性，理论最优解与 OLS 一致，但实现仍通过 LM 求解。</p><p class="ztext-empty-paragraph"><br></p><blockquote data-pid="2zKXdDc-"> 解释：对线性最小二乘而言，LM 通常不是必须的；但如果未来扩展到非线性摩擦/柔性/传感器偏置等模型，LM 会更通用。</blockquote><hr><h2>4.7 CLOE（闭环输出误差）</h2><p data-pid="uDeh2upH">通过“前向动力学仿真 + 输出误差最小化”来更新参数。<br>（即：在闭环系统中，用参数驱动的动力学模型进行仿真预测，再以输出误差作为代价函数迭代更新参数。）</p><blockquote data-pid="WULtJYy1"> 可理解为：把问题从“瞬时回归拟合”提升为“仿真一致性拟合”，通常对闭环数据更稳健，但实现复杂度也更高。</blockquote></div><span id="VirtualCatalogAnchorPoint"></span></span></div></div></div>
        </div>
</body>
</html>